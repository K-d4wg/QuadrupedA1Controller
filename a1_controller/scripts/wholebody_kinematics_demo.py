#!/usr/bin/env python3

# DEMO Script for Wholebodykinematics in Gazebo

import numpy as np
import rospy
import A1_kinematics
from sensor_msgs.msg import JointState
from geometry_msgs.msg import Pose
from unitree_legged_msgs.msg import MotorCmd
from Trajectory_Planner import Trajectory_Planner

# Pygame mostly generated by ChatGPT
command_topics = ["/a1_gazebo/FL_calf_controller/command",
                  "/a1_gazebo/FL_hip_controller/command",
                  "/a1_gazebo/FL_thigh_controller/command",
                  "/a1_gazebo/FR_calf_controller/command",
                  "/a1_gazebo/FR_hip_controller/command",
                  "/a1_gazebo/FR_thigh_controller/command",
                  "/a1_gazebo/RL_calf_controller/command",
                  "/a1_gazebo/RL_hip_controller/command",
                  "/a1_gazebo/RL_thigh_controller/command",
                  "/a1_gazebo/RR_calf_controller/command",
                  "/a1_gazebo/RR_hip_controller/command",
                  "/a1_gazebo/RR_thigh_controller/command"]

Kd = 5
Kp = 50

class PoseController:
    def __init__(self, width=400, height=300):
        
        # init ROS and Robots Positions:
        rospy.init_node('move_publisher', anonymous=True)
        rospy.Subscriber("/a1_gazebo/joint_states", JointState, self.joint_states_callback)
        rospy.Subscriber("/goal_pose", Pose, self.goal_pos_callback)
        self.freq = 500
        self.rate = rospy.Rate(self.freq)
        
        self.positions = []
        
        # standing configuration
        self.goal_pos = np.array([-1.9583591983757351, -0.0007974578255129927, 0.9794434592400876, 
                                  -1.9580158278760527, 0.00048751519737599835, 0.97896869674112, 
                                  -1.968766039552742, 0.0005508150816577739, 0.9651295186701967, 
                                  -1.968942195136563, 0.0002753686771956865, 0.9639652783917043])  
        
        # receive first message to set the starting position
        first_pos = rospy.wait_for_message("/a1_gazebo/joint_states",JointState,2)
        self.startup_pos =  np.array(first_pos.position)


        self.base_height = 0.225
        self.base_width = -0.0838
        self.hip_to_toe_pos = [[-0.0838, 0.225, 0.0],  # FL
                               [0.0838, 0.225, 0.0],  # FR
                               [-0.0838, 0.225, 0.0],  # RL
                               [0.0838, 0.225, 0.0]]  # RR
        
        self.goal_height = self.height = self.hip_to_toe_pos[0][1]
        self.goal_width = self.width = self.hip_to_toe_pos[0][0]
        self.goal_length = self.length = self.hip_to_toe_pos[0][2]
        
        self.goal_yaw = self.yaw = 0.0       
        self.goal_pitch = self.pitch = 0.0  
        self.goal_roll = self.roll = 0.0 
         

        self.global_positions = [[0, 0, 0],
                                 [0, 0, 0],
                                 [0, 0, 0],
                                 [0, 0, 0]]
        self.publishers = []
        for topic in command_topics:
            self.publishers.append(rospy.Publisher(topic,MotorCmd, queue_size=0))  # Create Publisher for each Joint
            
    
    def run(self):        
        # init MotorCMD Message
        motor_command = MotorCmd()
        motor_command.mode = 10  
        motor_command.Kp = Kp
        motor_command.Kd = Kd 
        
        tp = Trajectory_Planner()
        
        print("Standing up")
        num_steps = self.freq  # one sec to stand up at the start
        
        step = (self.goal_pos - self.startup_pos)/num_steps
        
        for i in range(num_steps):
            for i in range(0, len(self.publishers)):
                self.startup_pos[i] += step[i]
                motor_command.q = self.startup_pos[i]
    
                self.publishers[i].publish(motor_command)  
            self.rate.sleep()
        
        print("Listening to /goal_pose topic")
        while not rospy.is_shutdown():
            
            # calculate error for each joystick value to current value
            roll_error = (self.goal_roll - self.roll)/100
            yaw_error = (self.goal_yaw - self.yaw)/100  # dividing by 15 to smoothen the movement
            pitch_error = (self.goal_pitch - self.pitch)/100
            height_error = (self.goal_height -  self.height)/100
            length_error = (self.goal_length - self.length)/100
            width_error = (self.goal_width - self.width)/100
            
            # ROS CONTROL LOOP
            for legIdx in range(0,4):                

                # add translation
                self.hip_to_toe_pos[legIdx][0] += width_error
                self.hip_to_toe_pos[legIdx][1] += height_error
                self.hip_to_toe_pos[legIdx][2] += length_error                
                
                # calculate global positions (base to foot)
                self.global_positions[legIdx] = tp.global_foot_pos(legIdx, self.hip_to_toe_pos[legIdx])
                
                # apply RPY via rotation matrix
                self.global_positions[legIdx] = tp.apply_rpy(self.global_positions[legIdx][0], 
                                                          self.global_positions[legIdx][1], 
                                                          self.global_positions[legIdx][2], 
                                                          roll_error, pitch_error, yaw_error)
                
                # set new local position (hip to foot)
                self.hip_to_toe_pos[legIdx] = tp.local_foot_pos(legIdx,self.global_positions[legIdx])
                
                # get current leg angles from robot
                current_ths = [self.positions[legIdx*3 + 1], 
                               self.positions[legIdx*3 + 2], 
                               self.positions[legIdx*3]]
                
                # calculate closest solution for next position
                goal_ths  = A1_kinematics.calc_correct_thetas([self.hip_to_toe_pos[legIdx][0], 
                                                               self.hip_to_toe_pos[legIdx][1], 
                                                               self.hip_to_toe_pos[legIdx][2]], current_ths, legIdx % 2 == 0)
                
                # set goal angles for corresponding leg
                self.goal_pos[legIdx*3] = goal_ths[2]
                self.goal_pos[legIdx*3 + 1] = goal_ths[0]
                self.goal_pos[legIdx*3 + 2] = goal_ths[1] 
            # update the overall amount for each angle
            self.yaw += yaw_error
            self.pitch += pitch_error
            self.roll += roll_error
            self.height += height_error
            self.length += length_error
            self.width += width_error
            
            # send joint commands    
            for i in range(0, len(self.publishers)):
                motor_command.q = self.goal_pos[i]
                self.publishers[i].publish(motor_command)   
                
                
            self.rate.sleep()
            
        
    def joint_states_callback(self, data):
        self.positions = data.position
    
    def goal_pos_callback(self, data):
        self.goal_width = data.position.x
        self.goal_height = data.position.y
        self.goal_length = data.position.z
        
        self.goal_roll = data.orientation.x
        self.goal_pitch = data.orientation.y
        self.goal_yaw = data.orientation.z
        
if __name__ == "__main__":
    controller = PoseController()
    controller.run()
